{"version":3,"file":"jss-plugin-nested.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/extends.js","../../../node_modules/tiny-warning/dist/tiny-warning.esm.js","../src/index.js"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","import warning from 'tiny-warning'\n\nconst separatorRegExp = /\\s*,\\s*/g\nconst parentRegExp = /&/g\nconst refRegExp = /\\$([\\w-]+)/g\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n */\nexport default function jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return (match, key) => {\n      const rule = container.getRule(key) || (sheet && sheet.getRule(key))\n      if (rule) {\n        return rule.selector\n      }\n\n      warning(\n        false,\n        `[JSS] Could not find the referenced rule \"${key}\" in \"${\n          container.options.meta || container.toString()\n        }\".`\n      )\n      return key\n    }\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    const parentSelectors = parentProp.split(separatorRegExp)\n    const nestedSelectors = nestedProp.split(separatorRegExp)\n\n    let result = ''\n\n    for (let i = 0; i < parentSelectors.length; i++) {\n      const parent = parentSelectors[i]\n\n      for (let j = 0; j < nestedSelectors.length; j++) {\n        const nested = nestedSelectors[j]\n        if (result) result += ', '\n        // Replace all & by the parent or prefix & with the parent.\n        result +=\n          nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : `${parent} ${nested}`\n      }\n    }\n\n    return result\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return {...prevOptions, index: prevOptions.index + 1}\n\n    let {nestingLevel} = rule.options\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1\n\n    const options = {\n      ...rule.options,\n      nestingLevel,\n      index: container.indexOf(rule) + 1\n    }\n    // We don't need the parent name to be set options for chlid.\n    delete options.name\n    return options\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style\n\n    const styleRule = rule\n\n    const container = styleRule.options.parent\n    let options\n    let replaceRef\n    for (const prop in style) {\n      const isNested = prop.indexOf('&') !== -1\n      const isNestedConditional = prop[0] === '@'\n\n      if (!isNested && !isNestedConditional) continue\n\n      options = getOptions(styleRule, container, options)\n\n      if (isNested) {\n        let selector = replaceParentRefs(prop, styleRule.selector)\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet)\n        // Replace all $refs.\n        selector = selector.replace(refRegExp, replaceRef)\n\n        const name = `${styleRule.key}-${prop}`\n        if ('replaceRule' in container) {\n          // for backward compatibility\n          container.replaceRule(name, style[prop], {...options, selector})\n        } else {\n          container.addRule(name, style[prop], {...options, selector})\n        }\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container\n          .addRule(prop, {}, options)\n          .addRule(styleRule.key, style[prop], {selector: styleRule.selector})\n      }\n\n      delete style[prop]\n    }\n\n    return style\n  }\n\n  return {onProcessStyle}\n}\n"],"names":["separatorRegExp","parentRegExp","refRegExp","jssNested","getReplaceRef","container","sheet","match","key","rule","getRule","selector","warning","options","meta","toString","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","i","length","parent","j","nested","indexOf","replace","getOptions","prevOptions","index","nestingLevel","undefined","name","onProcessStyle","style","type","styleRule","replaceRef","prop","isNested","isNestedConditional","replaceRule","addRule"],"mappings":";;;;;;EAAe,SAAS,QAAQ,GAAG;EACnC,EAAE,QAAQ,GAAG,MAAM,CAAC,MAAM,IAAI,UAAU,MAAM,EAAE;EAChD,IAAI,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;EAC/C,MAAM,IAAI,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;AAChC;EACA,MAAM,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;EAC9B,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE;EAC/D,UAAU,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;EACpC,SAAS;EACT,OAAO;EACP,KAAK;AACL;EACA,IAAI,OAAO,MAAM,CAAC;EAClB,GAAG,CAAC;AACJ;EACA,EAAE,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;EACzC;;ECfA,SAAS,OAAO,CAAC,SAAS,EAAE,OAAO,EAAE;EACrC,EAAqB;EACrB,IAAI,IAAI,SAAS,EAAE;EACnB,MAAM,OAAO;EACb,KAAK;AACL;EACA,IAAI,IAAI,IAAI,GAAG,WAAW,GAAG,OAAO,CAAC;AACrC;EACA,IAAI,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE;EACxC,MAAM,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;EACzB,KAAK;AACL;EACA,IAAI,IAAI;EACR,MAAM,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC;EACxB,KAAK,CAAC,OAAO,CAAC,EAAE,EAAE;EAClB,GAAG;EACH;;ECfA,IAAMA,eAAe,GAAG,UAAxB;EACA,IAAMC,YAAY,GAAG,IAArB;EACA,IAAMC,SAAS,GAAG,aAAlB;EAEA;;;;EAGe,SAASC,SAAT,GAAqB;EAClC;EACA,WAASC,aAAT,CAAuBC,SAAvB,EAAkCC,KAAlC,EAAyC;EACvC,WAAO,UAACC,K